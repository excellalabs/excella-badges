import { DynamicModule } from '@nestjs/common';
import { MiddlewareConfigProxy, ModuleMetadata, Type } from '@nestjs/common/interfaces';
export declare type SyncOptions<T> = T & {
    /**
     * Same as NestJS buil-in `MiddlewareConfigProxy.forRoutes`
     * @see https://docs.nestjs.com/middleware#applying-middleware.
     * Use `forRoutes` and `exclude` to control which path should exec passed middleware.
     */
    forRoutes?: Parameters<MiddlewareConfigProxy['forRoutes']>;
    /**
     * Same as NestJS buil-in `MiddlewareConfigProxy.exclude`
     * @see https://docs.nestjs.com/middleware#applying-middleware.
     * Use `forRoutes` and `exclude` to control which path should exec passed middleware.
     */
    exclude?: Parameters<MiddlewareConfigProxy['exclude']>;
};
export interface AsyncOptions<T> extends Pick<ModuleMetadata, 'imports'> {
    useFactory: (...args: any[]) => SyncOptions<T> | Promise<SyncOptions<T>>;
    inject?: any[];
}
export interface FacadeModuleStatic<T> {
    forRoot(options: SyncOptions<T>): DynamicModule;
    forRootAsync(options: AsyncOptions<T>): DynamicModule;
}
export interface FacadeModuleStaticOptional<T> {
    forRoot(options?: SyncOptions<T>): DynamicModule;
    forRootAsync(options: AsyncOptions<T>): DynamicModule;
}
export declare function createModule<T extends any>(createMiddlewares: (options: T) => Function | Type<any> | Array<Type<any> | Function>): FacadeModuleStatic<T>;
